<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tag-Based Search</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            display: flex;
            margin: 0;
            padding: 20px;
            height: 100vh;
            box-sizing: border-box;
        }
        
        #editor-container {
            flex: 1;
            position: relative;
        }
        
        #editor {
            border: 1px solid #ccc;
            min-height: 300px;
            padding: 15px;
            outline: none;
            line-height: 1.6;
            font-size: 16px;
            border-radius: 5px;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
        }
        
        #results-pane {
            width: 250px;
            margin-left: 20px;
            border-radius: 5px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 15px;
            display: none;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
        }
        
        .result-item {
            cursor: pointer;
            padding: 10px;
            margin-bottom: 6px;
            border-radius: 4px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
            transition: transform 0.1s ease;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .result-item:hover {
            transform: translateY(-1px);
        }
        
        .tooltip {
            position: fixed;
            display: none;
            background: white;
            border-radius: 6px;
            padding: 12px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.2);
            z-index: 100;
            max-width: 300px;
            white-space: pre-wrap;
            font-family: monospace;
            font-size: 14px;
            line-height: 1.5;
        }

        .tagged-text {
            font-weight: bold;
            cursor: pointer;
            border-radius: 3px;
            padding: 1px 2px;
        }
    </style>
</head>
<body>
    <div id="editor-container">
        <div id="editor" contenteditable="true"></div>
        <div id="tooltip" class="tooltip"></div>
    </div>
    <div id="results-pane">
        <h3>Search Results</h3>
        <div id="results-list"></div>
    </div>

    <script>
        function base_url() {
            // return window.BASE_URL || "https://mcp.repo2graph.sphinx.chat";
            return "http://localhost:3000";
        }
        // Define colors for each NodeType
        const nodeTypeColors = {
            "Repository": "#6C8EBF",
            "Language": "#D79B00",
            "Directory": "#82B366",
            "File": "#9673A6",
            "Import": "#B85450",
            "Class": "#D5E8D4",
            "Trait": "#DAE8FC",
            "Library": "#F8CECC",
            "Function": "#FFE6CC",
            "Test": "#FFF2CC",
            "E2etest": "#E1D5E7",
            "Endpoint": "#D4E1F5",
            "Request": "#C3ABD0",
            "Datamodel": "#F5B7B1",
            "Page": "#AED6F1"
        };

        // DOM elements
        const editor = document.getElementById('editor');
        const resultsPane = document.getElementById('results-pane');
        const resultsList = document.getElementById('results-list');
        const tooltip = document.getElementById('tooltip');

        // Current state
        let searchTimeout;
        let currentTag = '';
        let lastRange = null;

        // Initialize
        editor.focus();

        // Event listeners
        editor.addEventListener('input', handleInput);
        editor.addEventListener('keydown', handleKeydown);

        function handleInput(e) {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(() => {
                const selection = window.getSelection();
                if (!selection.rangeCount) return;
                
                const range = selection.getRangeAt(0);
                const hashtag = findHashtagBeforeCursor(range);
                
                if (hashtag) {
                    currentTag = hashtag;
                    lastRange = range.cloneRange(); // Save the range for later use
                    searchForTag(hashtag);
                } else {
                    hideResultsPane();
                }
            }, 200);
        }

        function handleKeydown(e) {
            // Close results pane on escape
            if (e.key === 'Escape') {
                hideResultsPane();
            }
        }

        function findHashtagBeforeCursor(range) {
            if (!range.collapsed) return null;
            
            const textNode = range.startContainer;
            if (textNode.nodeType !== Node.TEXT_NODE) return null;
            
            const text = textNode.textContent;
            const cursorPos = range.startOffset;
            
            // Find the start of the hashtag
            let hashStart = -1;
            for (let i = cursorPos - 1; i >= 0; i--) {
                if (text[i] === '#') {
                    hashStart = i;
                    break;
                } else if (!/[\w-]/.test(text[i])) {
                    break;
                }
            }
            
            if (hashStart === -1) return null;
            
            // Extract the hashtag without the # symbol
            const hashtagText = text.substring(hashStart + 1, cursorPos);
            
            return hashtagText && /^[\w-]+$/.test(hashtagText) ? hashtagText : null;
        }

        async function searchForTag(tag) {
            try {
                const response = await fetch(`${base_url()}/search?query=${encodeURIComponent(tag)}`);
                if (!response.ok) throw new Error(`HTTP error ${response.status}`);
                
                const data = await response.json();
                displaySearchResults(data);
            } catch (error) {
                console.error("Search error:", error);
                hideResultsPane();
            }
        }

        function displaySearchResults(results) {
            resultsList.innerHTML = '';
            
            if (!results || results.length === 0) {
                hideResultsPane();
                return;
            }
            
            results.forEach((result) => {
                const resultItem = document.createElement('div');
                resultItem.className = 'result-item';
                resultItem.textContent = result.properties.name || 'Unnamed';
                
                const color = nodeTypeColors[result.node_type] || '#ccc';
                resultItem.style.backgroundColor = color;
                resultItem.style.color = getContrastColor(color);
                
                // Add hover event
                resultItem.addEventListener('mouseover', () => {
                    showTooltip(resultItem, result.properties.body, true);
                });
                
                resultItem.addEventListener('mouseout', () => {
                    hideTooltip();
                });
                
                // Add click event
                resultItem.addEventListener('click', () => {
                    replaceHashtagWithStyledSpan(result);
                    hideResultsPane();
                });
                
                resultsList.appendChild(resultItem);
            });
            
            resultsPane.style.display = 'block';
        }

        function replaceHashtagWithStyledSpan(result) {
            if (!lastRange) return;
            
            // Restore the saved range
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(lastRange);
            
            const range = selection.getRangeAt(0);
            const textNode = range.startContainer;
            
            if (textNode.nodeType !== Node.TEXT_NODE) return;
            
            const text = textNode.textContent;
            const cursorPos = range.startOffset;
            
            // Find the start of the hashtag
            let hashStart = -1;
            for (let i = cursorPos - 1; i >= 0; i--) {
                if (text[i] === '#') {
                    hashStart = i;
                    break;
                } else if (!/[\w-]/.test(text[i])) {
                    break;
                }
            }
            
            if (hashStart === -1) return;
            
            // Create a range for the hashtag
            const hashtagRange = document.createRange();
            hashtagRange.setStart(textNode, hashStart);
            hashtagRange.setEnd(textNode, cursorPos);
            
            // Create a styled span
            const color = nodeTypeColors[result.node_type] || '#ccc';
            const tagSpan = document.createElement('span');
            tagSpan.className = 'tagged-text';
            tagSpan.style.color = color;
            tagSpan.style.fontWeight = 'bold';
            tagSpan.textContent = `#${currentTag}`;
            tagSpan.dataset.body = result.properties.body || '';
            tagSpan.dataset.nodeType = result.node_type;
            
            // Add hover event
            tagSpan.addEventListener('mouseover', (e) => {
                showTooltip(e.target, result.properties.body);
            });
            
            tagSpan.addEventListener('mouseout', () => {
                hideTooltip();
            });
            
            // Replace the hashtag with the styled span
            hashtagRange.deleteContents();
            hashtagRange.insertNode(tagSpan);
            
            // Move cursor after the span
            const newRange = document.createRange();
            newRange.setStartAfter(tagSpan);
            newRange.collapse(true);
            selection.removeAllRanges();
            selection.addRange(newRange);
            
            // Reset state
            currentTag = '';
            lastRange = null;
        }

        function showTooltip(element, bodyText, leftof) {
            const rect = element.getBoundingClientRect();
            if (leftof) {
                tooltip.style.left = `${rect.left - 340}px`;
            } else {
                tooltip.style.left = `${rect.right + 10}px`;
            }
            tooltip.style.top = `${rect.top}px`;
            tooltip.textContent = getFirst10Lines(bodyText);
            tooltip.style.display = 'block';
        }

        function hideTooltip() {
            tooltip.style.display = 'none';
        }

        function hideResultsPane() {
            resultsPane.style.display = 'none';
        }

        function getFirst10Lines(text) {
            if (!text) return "No content available";
            const lines = text.split('\n');
            return lines.slice(0, 10).join('\n');
        }

        function getContrastColor(hexColor) {
            // Convert hex to RGB
            const r = parseInt(hexColor.substring(1, 3), 16);
            const g = parseInt(hexColor.substring(3, 5), 16);
            const b = parseInt(hexColor.substring(5, 7), 16);
            
            // Calculate luminance
            const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
            
            // Return black or white based on luminance
            return luminance > 0.5 ? '#000000' : '#ffffff';
        }

        // Global event listeners
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.tagged-text') && !e.target.closest('.result-item')) {
                hideTooltip();
                if (!e.target.closest('#editor')) {
                    hideResultsPane();
                }
            }
        });
    </script>
</body>
</html>