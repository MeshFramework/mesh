<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tag-Based Search</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            display: flex;
            flex-direction: column-reverse;
            margin: 0;
            padding: 20px;
            height: 100vh;
            box-sizing: border-box;
        }
        
        .content-container {
            display: flex;
            position: relative;
        }
        
        #editor-container {
            flex: 1;
            position: relative;
        }
        
        #editor {
            border: 1px solid #ccc;
            min-height: 300px;
            padding: 15px;
            outline: none;
            line-height: 1.6;
            font-size: 16px;
            border-radius: 5px 0 0 5px;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
        }
        
        #results-pane {
            width: 150px;
            border: 1px solid #ccc;
            border-left: none;
            border-radius: 0 5px 5px 0;
            padding: 10px;
            display: none;
            overflow-y: auto;
            background-color: #f9f9f9;
            height: calc(300px + 8px); /* Match editor height + its borders */
        }
        
        #results-pane h3 {
            margin-top: 0;
            font-size: 14px;
            color: #555;
            margin-bottom: 10px;
            text-align: center;
        }
        
        .result-item {
            cursor: pointer;
            padding: 6px 10px;
            margin-bottom: 8px;
            border-radius: 20px;
            transition: transform 0.1s ease, box-shadow 0.1s ease;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-size: 13px;
            color: white;
            text-align: center;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        
        .result-item:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        
        .tooltip {
            position: absolute;
            display: none;
            background: white;
            border-radius: 6px;
            padding: 12px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.2);
            z-index: 100;
            width: calc(100% - 24px);
            height: 300px;
            white-space: pre-wrap;
            font-family: monospace;
            font-size: 14px;
            line-height: 1.5;
            overflow-y: auto;
            top: -327px; /* Position above the editor */
        }

        .tagged-text {
            font-weight: bold;
            cursor: pointer;
            border-radius: 3px;
            padding: 1px 2px;
        }
    </style>
</head>
<body>
    <div class="content-container">
        <div class="tooltip" id="tooltip"></div>
        <div id="editor-container">
            <div id="editor" contenteditable="true"></div>
        </div>
        <div id="results-pane">
            <h3>Search Results</h3>
            <div id="results-list"></div>
        </div>
    </div>

    <script>
        function base_url() {
            // return window.BASE_URL || "https://mcp.repo2graph.sphinx.chat";
            return "http://localhost:3000";
        }
        // Define colors for each NodeType (darker versions for better contrast with white text)
        const nodeTypeColors = {
            "Repository": "#2C5985", // Darker blue
            "Language": "#A35D00",   // Darker orange
            "Directory": "#3A7336",  // Darker green
            "File": "#5A3973",       // Darker purple
            "Import": "#8B2E2A",     // Darker red
            "Class": "#4A7D4A",      // Darker light green
            "Trait": "#3B6EB5",      // Darker light blue
            "Library": "#A83333",    // Darker pink
            "Function": "#C67000",   // Darker light orange
            "Test": "#B7940A",       // Darker yellow
            "E2etest": "#7C4A85",    // Darker lavender
            "Endpoint": "#385D8A",   // Darker blue gray
            "Request": "#6B4A7A",    // Darker medium purple
            "Datamodel": "#A13939",  // Darker salmon
            "Page": "#2980B9"        // Darker sky blue
        };

        // DOM elements
        const editor = document.getElementById('editor');
        const resultsPane = document.getElementById('results-pane');
        const resultsList = document.getElementById('results-list');
        const tooltip = document.getElementById('tooltip');
        const editorContainer = document.getElementById('editor-container');
        const contentContainer = document.querySelector('.content-container');

        // Current state
        let searchTimeout;
        let currentTag = '';
        let lastRange = null;

        // Initialize
        editor.focus();

        // Event listeners
        editor.addEventListener('input', handleInput);
        editor.addEventListener('keydown', handleKeydown);

        function handleInput(e) {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(() => {
                const selection = window.getSelection();
                if (!selection.rangeCount) return;
                
                const range = selection.getRangeAt(0);
                const hashtag = findHashtagBeforeCursor(range);
                
                if (hashtag) {
                    currentTag = hashtag;
                    lastRange = range.cloneRange(); // Save the range for later use
                    searchForTag(hashtag);
                } else {
                    hideResultsPane();
                }
            }, 200);
        }

        function handleKeydown(e) {
            // Close results pane on escape
            if (e.key === 'Escape') {
                hideResultsPane();
            }
        }

        function findHashtagBeforeCursor(range) {
            if (!range.collapsed) return null;
            
            const textNode = range.startContainer;
            if (textNode.nodeType !== Node.TEXT_NODE) return null;
            
            const text = textNode.textContent;
            const cursorPos = range.startOffset;
            
            // Find the start of the hashtag
            let hashStart = -1;
            for (let i = cursorPos - 1; i >= 0; i--) {
                if (text[i] === '#') {
                    hashStart = i;
                    break;
                } else if (!/[\w-]/.test(text[i])) {
                    break;
                }
            }
            
            if (hashStart === -1) return null;
            
            // Extract the hashtag without the # symbol
            const hashtagText = text.substring(hashStart + 1, cursorPos);
            
            return hashtagText && /^[\w-]+$/.test(hashtagText) ? hashtagText : null;
        }

        async function searchForTag(tag) {
            try {
                const response = await fetch(`${base_url()}/search?query=${encodeURIComponent(tag)}`);
                if (!response.ok) throw new Error(`HTTP error ${response.status}`);
                
                const data = await response.json();
                displaySearchResults(data);
            } catch (error) {
                console.error("Search error:", error);
                hideResultsPane();
            }
        }

        function displaySearchResults(results) {
            resultsList.innerHTML = '';
            
            if (!results || results.length === 0) {
                hideResultsPane();
                return;
            }
            
            results.forEach((result) => {
                const resultItem = document.createElement('div');
                resultItem.className = 'result-item';
                resultItem.textContent = result.properties.name || 'Unnamed';
                
                const color = nodeTypeColors[result.node_type] || '#333';
                resultItem.style.backgroundColor = color;
                
                // Add hover event
                resultItem.addEventListener('mouseover', () => {
                    showTooltip(result.properties.body);
                });
                
                resultItem.addEventListener('mouseout', () => {
                    hideTooltip();
                });
                
                // Add click event
                resultItem.addEventListener('click', () => {
                    replaceHashtagWithStyledSpan(result);
                    hideResultsPane();
                });
                
                resultsList.appendChild(resultItem);
            });
            
            resultsPane.style.display = 'block';
        }

        function replaceHashtagWithStyledSpan(result) {
            if (!lastRange) return;
            
            // Restore the saved range
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(lastRange);
            
            const range = selection.getRangeAt(0);
            const textNode = range.startContainer;
            
            if (textNode.nodeType !== Node.TEXT_NODE) return;
            
            const text = textNode.textContent;
            const cursorPos = range.startOffset;
            
            // Find the start of the hashtag
            let hashStart = -1;
            for (let i = cursorPos - 1; i >= 0; i--) {
                if (text[i] === '#') {
                    hashStart = i;
                    break;
                } else if (!/[\w-]/.test(text[i])) {
                    break;
                }
            }
            
            if (hashStart === -1) return;
            
            // Split text into before, tag, and after
            const beforeText = text.substring(0, hashStart);
            const afterText = text.substring(cursorPos);
            
            // Create document fragment
            const fragment = document.createDocumentFragment();
            
            // Add text before the hashtag
            if (beforeText) {
                fragment.appendChild(document.createTextNode(beforeText));
            }
            
            // Create styled span for the hashtag
            const color = nodeTypeColors[result.node_type] || '#333';
            const tagSpan = document.createElement('span');
            tagSpan.className = 'tagged-text';
            tagSpan.style.color = color;
            tagSpan.style.fontWeight = 'bold';
            tagSpan.textContent = `#${currentTag}`;
            tagSpan.dataset.body = result.properties.body || '';
            tagSpan.dataset.nodeType = result.node_type;
            
            // Add hover event
            tagSpan.addEventListener('mouseover', () => {
                showTooltip(result.properties.body);
            });
            
            tagSpan.addEventListener('mouseout', () => {
                hideTooltip();
            });
            
            // Add styled span to fragment
            fragment.appendChild(tagSpan);
            
            // Create a separate text node for afterText
            // If afterText is empty, use a zero-width space to ensure there's a valid cursor position
            const afterNode = document.createTextNode(afterText || '\u200B');
            fragment.appendChild(afterNode);
            
            // Replace the original text node with our new structure
            textNode.parentNode.replaceChild(fragment, textNode);
            
            // Position cursor at the beginning of the text after the tag
            const newRange = document.createRange();
            newRange.setStart(afterNode, 0);
            newRange.collapse(true);
            selection.removeAllRanges();
            selection.addRange(newRange);
            
            // Reset state
            currentTag = '';
            lastRange = null;
        }

        function showTooltip(bodyText) {
            tooltip.textContent = getFirst10Lines(bodyText);
            tooltip.style.display = 'block';
        }

        function hideTooltip() {
            tooltip.style.display = 'none';
        }

        function hideResultsPane() {
            resultsPane.style.display = 'none';
        }

        function getFirst10Lines(text) {
            if (!text) return "No content available";
            const lines = text.split('\n');
            return lines.slice(0, 10).join('\n');
        }

        // Global event listeners
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.tagged-text') && !e.target.closest('.result-item')) {
                hideTooltip();
                if (!e.target.closest('#editor')) {
                    hideResultsPane();
                }
            }
        });
    </script>
</body>
</html>